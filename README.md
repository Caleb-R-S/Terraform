# Terraform information
##Terraform Basics
``` 
<block> <parameters> {
	key1 = value1
	key2 = value2
}
``` 
In `<block>` we get the block name
In <parameters>, there are two parts:
	- "provider_resource"
	- "resourceName"
For example, "local_file" follows this, local=provider and file=resourceType

When creating a file, you need to specify the filename, providing an absolute path 
and you also need to provide the content

If you end up adding new .tf files as you go along, the you need to check
to see if you have added any new providers. If you have added a new provider,
you need to run `terraform init` again to install the new dependencies

## Running Terraform
- terraform init
- terraform plan (-out and file name if you want to save its plan)
- terraform apply
- terraform destroy

## Variables
- Generally kept in a "variables.tf" file
- Declared like:


```
	variable "nameOfVariable" {
		default = "textValue"
		// Not required but suggested
		type = string //string, number, bool, list, map, object, tuple
		description = "this is my var" 
	}

	variable "BellaTheDog" {
		type = object({
			name = string
			color = string
			age = number 
			food = list(string)
			favorite_pet = bool
		})
	}

	default {
		name = "bella"
		color = "brown"
		age = 7
		food = ["fish", "chicken", "turkey"]
		favorite_pet = true
	}


	variable myTuple {
		type = tuple([number, string, bool])	
		default = [7, "cat", true] 
		// This wouldn't work because we have too many values in the tuple
		default = [7, "cat", true, "dog"]
	}
```

- To access variables in other files you can use `var.nameOfVariable`
	- To access a list it would be `var.name[i]`
	- To make a list of numbers you would say [1, 2]
	- To access a map it would be `var.name["key-value"]`
	- To make a tuple, you have to specify what types are going into it, you have to pass exactly how many variables you expect to it
- If you do not specifiy a variable default, you will be asked to provide one during the `terraform apply` phase
	- Another option is to specify the variable as a command line argument, this would look like:
		-`terraform apply -var "myVar=This is my var"`
	- Another option is to specify a TF_VAR using the `export` command:
		-`$ export TF_VAR_myVar="test variable"`
	- Finally, we can make a .tfvars or a .tfvars.json file 
		- filename = "/myfile"
		- content = "my content"
	- Files named terraform.tfvars or anything named *.auto.tfvars will get automatically loaded.
	- If I named a file "variables.tfvars", I would need to give a tag in the terraform apply file
		- `terraform apply -var-file variables.tfvars`
		- `terraform apply` woule work if my file were variables.auto.tfvars or terraform.tfvars
- If a variable is defined multiple times, the script has a heiarchy to determine its final value:

| Order | Value Rendered |
|---|----------------|
| 1 | Environment variables `export TF_VAR_filename="/path"` |
| 2 | terraform.tfvars `filename = "/other/path"` |
| 3 | *.auto.tfvars (In alphabetical order) `filename="/another/path"` |
| 4 | -var or -var-file (command line flags) `terraform apply -var "filename=/actual/path"` |

### Dependencies
- We can make use of ${provider_resourceType.resourceName.attributeToBeUsed} to reference the output of another resource. This is called a ***reference expression***
```
resource "local_file" "pet" {
	filename = var.filename
	content = "My favorite pet is ${random_pet.my-pet.id}"
	
}

resource "random_pet" "my-pet" {
	prefix = var.prefix
	separator = var.separator
	length = var.length
}
```
The example above creates an ***implicit*** dependency. Terraform is smart enough to know that
the random_pet resource needs to be rendered first because the local_file depends on it

If we wanted to load a resource after something else because it "depends on" it, then we can create an ***explicit*** dependency by doing the following 
```
resource "local_file" "pet" {
	filename = var.filename
	content = "My favorite pet is ${random_pet.my-pet.id}"
	depends_on = [
		random_pet.my-pet
	]
	
}

resource "random_pet" "my-pet" {
	prefix = var.prefix
	separator = var.separator
	length = var.length
}
```
- Explicit dependencies are necessary when a resource relies on another resource but does not use the reference expression shown above

###Output Variables
- In addition to input variables, we can assign outputs of resources to variables as well
```
output = "<variable_name>" {
	value = "<variable_value>"
	<arguments>
}
```
- For example we may have: 
```
resource "local_file" "pet" {
	filename = var.filename
	content = "My favorite pet is ${random_pet.my-pet.id}"
}

resource "random_pet" "my-pet" {
	prefix = var.prefix
	separator = var.separator
	length = var.length
}

output pet-name {
	value = random_pet.my-pet.id
	description = "Record the value of pet ID generated by the random_pet resource"
}
```
- You can now use the command `terraform output` to get a list of all of the output values created in the `terraform apply` stage
	- You can also output the value of a specific variable by providing the name
	- That looks like:
	```
	$ terraform output pet-name
	Mrs.gibbon
	```
	- The most common use case for output variable are to write things to the screen during `terraform apply`
	- These can also be useful to feed into other iac tools like an add-on shell scripts or 'Ansible Playbook'

## State
- A state file can be considered to be a blueprint of all the resources that terraform manages in its environment
- Terraform uses "state" to keep track of metadata like dependencies, etc.. This allows it to know what order to delete or create files in
- Terraform uses cached information about state to make its process faster.
	- You can force terraform to use just cached info by:
		```
		$ terraform plan --refresh=false
		```
- You should keep the terraform state files in a remote location to allow all team members to access it.
- Don't run terraform when someone else is running it. This could cause unexpected errors
- State is non optional. It contains sensative information. It should be stored in a secure location
- There are essentially two kinds of terraform files, provision files and state files
	- Store provision/config files on a git service
	- Store state files on protected servers like Amazon S3, TerraformCloud, or any other protected service
- Never try to manually edit the state files. Rely on state commands to do that

## Teraform Commands
- `terraform validate`
	- Determines if the syntax in your terraform file is correct
	- Only performs a superficial validation. It only looks at whether our commands and arguments are correct, not what we are actually passing as parameters

- `terraform fmt`
	- Also known as the terraform format command
	- This command scans the files in the working directory and puts them into a canonical format
	- Useful for increasing readability of your terraform

- `terraform show`
	- Prints out the current state of the infrastructure as seen by terraform
	- Using the -json flag allows you to view the format as a json object

- `terraform providers`
	- Gives a list of all providers required by configuration
	- We can add `mirror` subcommand with a filename to copy the provider configuration to another file

- `terraform refresh`
	- This synchronizes the terraform state with any changes that have happened because of something other than terraform
	- This command does not modify any resources, rather it just updates the state file
	- Terraform automatically refreshes before it executes commands like `plan` and `apply`

- `terraform graph`
	- This command creates a visual represntation of the dependencies in a terraform configuration or an execution plan
	- You can use this in conjuction with a service like `graphviz` on ubuntu
	- An example command would be:
		`terraform graph | dot -Tsvg > graph.svg`

## Mutable vs. Immutable Infrastructure
- When changing a file within terraform, it first deletes the old file and then puts in the new one, that is because the resource is immutable
- A Mutable Infrastructure:
	- Resources that keep everything the same and are just updated
	- Like a server that updates its os software to the next level
	- After a while, if we have multiple servers that do the same thing, and one doesn't have the right dependencies, it may fail to update. That would leave us with a server that is at a different stage than the others. This is known as configuration drift
- An Immutable Infrastructure:
	- A resource, maybe a server running v1.7 is deleted and completely replaced by a server with v1.8
	- While immutability is not immune to conficuration drift, it is much more resilient and robust. This also makes it easier to debug

## Lifecycle Rules
- Sometimes we may not want an old resource to be deleted after changing it, or we may even want to create the update before we delete the old structure
- We can use lifecycle blocks to accomplish this:
```
resource "local_file" "pet" {
	filename = "/root/pets.txt"
	content = "We love pets!"
	file_permission = "0700"
	lifecycle { // Note the lifecycle block is in the resource block
		create_before_destroy = true
		// Other option
		prevent_destroy = true
	}
}


```
- The `prevent_destroy` option can be useful to prevent resources like a database from getting destroyed. It is important to note the this will not prevent the resource from getting destroyed by the `terraform destroy` command, only an apply that may try to make changes to the resource
- Beyond those two options, there is a third that "ignores changes"
- The `create_before_destroy` isn't a good idea with files. The OS wont allow us to create two files with the exact same name, so a new file won't get created. The problem comes after the destroy phase deletes the old file, however, a new file was never created, so no we are left without the files we thought we were creating 
```
resource "aws_instance" "webserver" {
	ami = "ami-aas99902hahkjad79dja82k"
	instance_type = "t2.micro"
	tags = {
		Name = "ProjectA-Webserver"
	}
}

lifecycle {
	ignore_changes = [
		tags
	]
	// This can also be done like ignore_changes = all
}
```
- This will prevent changes from any other terrafrom resources
- Every time something is updated or destroyed and recreated, it will receive a new id

## Data sources
- There is a large possibility that at some point in time, a resources will be created by a tool other than terraform.
- For example, we may make a cloud component on aws manually or add a file that terraform doesn't have control over
- If we want terraform to be able to read their data or interact with them, we can use the data block:
```
data "local_file" "dog" {
	filename = "/root/dog.txt" // Different resources will have different arguments. Research to find what arguments your data blocks may need
}
```
- After the resource is initialized, we can access it through the `data object` in terraform
- For example we could:
```
resource "local_file" "pet" {
	filename = "/root/pets.txt"
	content = data.local_file.dog.content
}

data "local_file" "dog" {
	filename = "/root/dog.txt"
}
```
- Blocks starting with `resource` are considered "managed" resources while blocks initialized with the `data` keyword are considered "data" resources
- "Managed" resources are created, updated, and destroyed by terraform while "Data" resources are only read by terraform

## Meta Arguments
- We can create multiple instances of the same instance. 
- These arguments change how the resource interacts in the terraform environment
	- The `depends_on` and `lifecycle` blocks are examples of meta arguments
- `count`
```
resource "local_file" "pet" {
	filename = var.filename[count.index] //We could also use ${count.index} to interpolate a string
	count = length(var.filename)
}

variable "filename" {
	default = [
		"root/pets.txt",
		"root/dogs.txt",
		"root/cats.txt"
	]
}
```
- This creates a list of resources

- `for_each` is another valid meta argument
- This only works on maps and sets, because those ensure unique values
```
resource "local_file" "pet" {
	filename = each.value
	for_each = toset(var.filename) // This converts our list to a set
}

variable "filename" {
	//type=set(string) makes sure that we have a set
	default = [
		"root/pets.txt",
		"root/dogs.txt",
		"root/cats.txt"
	]
}
```
- If we output the value of `local_file.pet` now, we will see that it is stored in a map. When creating multiple resources with `count` we get a list and with `for_each` we get a map
- There are other meta arguments like `provisoners`, `providers`, and `backends` 

## Version Constraints
- `terraform init` uses the newest version of the resources avaialbe from the provider
- We can specify which version of the resource we want to usea
- If we wanted to use a different version we could to the following:
```
terraform {
	required_providers {
		local = {
			source = "hashicorp/local"
			version = "1.4.0" // We could also use "!= 2.0.0" which means use the previous version available to 2.0.0 we can also use < and > to specify to use versions greater than or less than a specific number
			// We can combine these like `>1.2.0, <2.0.0, !=1.4.0`
			// We can use `~>1.2.0` to allow us to use any incremental version of "1.2", we could also do `~> 1.2`, which would give 1.3, 1.4, up to 1.9 if available
		}
	}
}
```
- The terraform block is used to configure settings about terraform itself
